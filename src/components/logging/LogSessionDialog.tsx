import React, { useState, useEffect, useMemo } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from '@/components/ui/use-toast';
import { supabaseRequest } from '@/utils/supabaseRequest';
import { useAuth } from '@/components/AuthProvider';
import { Task } from '@/types/tasks';
import { differenceInMinutes, format, parse, isValid, isAfter } from 'date-fns';
import { cn } from '@/lib/utils';
import { Loader2, Save } from 'lucide-react';

interface LogSessionDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSessionLogged?: () => void; // Optional callback after successful logging
}

// Define session types available for logging
const sessionTypes = ['Manual Focus', 'Deep Work', 'Learning', 'Meeting', 'Other'];

export const LogSessionDialog: React.FC<LogSessionDialogProps> = ({ isOpen, onClose, onSessionLogged }) => {
    const { user } = useAuth();
    const { toast } = useToast();
    const [startDate, setStartDate] = useState(format(new Date(), 'yyyy-MM-dd'));
    const [startTime, setStartTime] = useState(format(new Date(Date.now() - 60 * 60 * 1000), 'HH:mm')); // Default 1 hr ago
    const [endDate, setEndDate] = useState(format(new Date(), 'yyyy-MM-dd'));
    const [endTime, setEndTime] = useState(format(new Date(), 'HH:mm'));
    const [sessionType, setSessionType] = useState<string>(sessionTypes[0]);
    const [notes, setNotes] = useState('');
    const [linkedTaskId, setLinkedTaskId] = useState<string | null>(null);
    const [availableTasks, setAvailableTasks] = useState<Task[]>([]);
    const [isSaving, setIsSaving] = useState(false);
    const [isLoadingTasks, setIsLoadingTasks] = useState(false);

    // Fetch tasks for linking
    useEffect(() => {
        if (!user?.id || !isOpen) return;
        setIsLoadingTasks(true);
        supabaseRequest<Task[]>('focus_tasks', 'GET', {
            filters: { user_id: user.id }, // Fetch all user tasks for simplicity
            orderBy: { column: 'created_at', ascending: false }
        })
        .then(tasks => setAvailableTasks(tasks || []))
        .catch(err => {
            console.error("Error fetching tasks for dialog:", err);
            toast({ title: 'Error Loading Tasks', description: 'Could not load tasks for linking.', variant: 'destructive' });
        })
        .finally(() => setIsLoadingTasks(false));
    }, [user?.id, isOpen, toast]);

    // Combine date and time strings into Date objects
    const startDateTime = useMemo(() => {
        try {
            return parse(`${startDate} ${startTime}`, 'yyyy-MM-dd HH:mm', new Date());
        } catch { return null; }
    }, [startDate, startTime]);

    const endDateTime = useMemo(() => {
        try {
            return parse(`${endDate} ${endTime}`, 'yyyy-MM-dd HH:mm', new Date());
        } catch { return null; }
    }, [endDate, endTime]);

    // Calculate duration
    const duration = useMemo(() => {
        if (startDateTime && endDateTime && isValid(startDateTime) && isValid(endDateTime) && isAfter(endDateTime, startDateTime)) {
            return differenceInMinutes(endDateTime, startDateTime);
        }
        return null;
    }, [startDateTime, endDateTime]);

    const handleSave = async () => {
        if (!user?.id || !startDateTime || !endDateTime || !duration || duration <= 0) {
            toast({ title: 'Invalid Input', description: 'Please ensure start and end times are valid and end time is after start time.', variant: 'destructive' });
            return;
        }
        if (!sessionType) {
             toast({ title: 'Invalid Input', description: 'Please select a session type.', variant: 'destructive' });
             return;
        }

        setIsSaving(true);
        try {
            const loggedSessionData = {
                user_id: user.id,
                start_time: startDateTime.toISOString(),
                end_time: endDateTime.toISOString(),
                // duration_minutes is generated by DB
                session_type: sessionType,
                task_id: linkedTaskId || null,
                notes: notes.trim() || null,
            };

            await supabaseRequest('logged_sessions', 'POST', { data: loggedSessionData });

            toast({ title: 'Session Logged', description: `Logged ${duration} minutes of ${sessionType}.` });
            onSessionLogged?.(); // Call optional callback
            handleClose(); // Close dialog on success
        } catch (error: any) {
            console.error("Error logging session:", error);
            toast({ title: 'Error Logging Session', description: error.message, variant: 'destructive' });
        } finally {
            setIsSaving(false);
        }
    };

    // Reset state when dialog closes
    const handleClose = () => {
        setStartDate(format(new Date(), 'yyyy-MM-dd'));
        setStartTime(format(new Date(Date.now() - 60 * 60 * 1000), 'HH:mm'));
        setEndDate(format(new Date(), 'yyyy-MM-dd'));
        setEndTime(format(new Date(), 'HH:mm'));
        setSessionType(sessionTypes[0]);
        setNotes('');
        setLinkedTaskId(null);
        setIsSaving(false);
        onClose(); // Call the parent close handler
    };

    return (
        <Dialog open={isOpen} onOpenChange={(open) => !open && handleClose()}>
            <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>Log New Session</DialogTitle>
                    <DialogDescription>Manually add a focus, learning, or other work session.</DialogDescription>
                </DialogHeader>
                <div className="grid gap-4 py-4">
                     {/* Start Time */}
                     <div className="grid grid-cols-3 items-center gap-4">
                        <Label htmlFor="start-date" className="text-right col-span-1">Start</Label>
                        <Input id="start-date" type="date" value={startDate} onChange={e => setStartDate(e.target.value)} className="col-span-2"/>
                        {/* <Input id="start-time" type="time" value={startTime} onChange={e => setStartTime(e.target.value)} className="col-span-1"/> */}
                         {/* Simple text input for time - consider a TimePicker component later */}
                         <Label htmlFor="start-time" className="text-right col-span-1 sr-only">Start Time</Label>
                         <Input id="start-time" type="time" value={startTime} onChange={e => setStartTime(e.target.value)} className="col-span-2" step="300" />
                     </div>
                     {/* End Time */}
                     <div className="grid grid-cols-3 items-center gap-4">
                        <Label htmlFor="end-date" className="text-right col-span-1">End</Label>
                        <Input id="end-date" type="date" value={endDate} onChange={e => setEndDate(e.target.value)} className="col-span-2"/>
                        {/* <Input id="end-time" type="time" value={endTime} onChange={e => setEndTime(e.target.value)} className="col-span-1"/> */}
                        <Label htmlFor="end-time" className="text-right col-span-1 sr-only">End Time</Label>
                        <Input id="end-time" type="time" value={endTime} onChange={e => setEndTime(e.target.value)} className="col-span-2" step="300" />
                     </div>

                    {/* Calculated Duration Display */}
                     {duration !== null && duration > 0 && (
                        <div className="text-right text-sm font-medium text-muted-foreground pr-1">
                             Duration: {duration} minutes
                        </div>
                     )}
                     {duration !== null && duration <= 0 && (
                         <div className="text-right text-sm font-medium text-destructive pr-1">
                             End time must be after start time.
                        </div>
                     )}

                    {/* Session Type */}
                    <div className="grid grid-cols-3 items-center gap-4">
                        <Label htmlFor="session-type" className="text-right">Type</Label>
                         <Select value={sessionType} onValueChange={setSessionType}>
                            <SelectTrigger className="col-span-2"><SelectValue placeholder="Select type..." /></SelectTrigger>
                            <SelectContent>
                                {sessionTypes.map(type => (
                                    <SelectItem key={type} value={type}>{type}</SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    </div>

                     {/* Linked Task */}
                     <div className="grid grid-cols-3 items-center gap-4">
                         <Label htmlFor="linked-task" className="text-right">Link Task <span className="text-xs text-muted-foreground">(Optional)</span></Label>
                          <Select value={linkedTaskId ?? ''} onValueChange={(value) => setLinkedTaskId(value || null)} disabled={isLoadingTasks}>
                             <SelectTrigger className="col-span-2">
                                 <SelectValue placeholder={isLoadingTasks ? "Loading tasks..." : "Link to a task..."} />
                             </SelectTrigger>
                             <SelectContent>
                                 <SelectItem value="">-- None --</SelectItem>
                                 {availableTasks.map(task => (
                                    <SelectItem key={task.id} value={task.id} className="truncate">{task.title}</SelectItem>
                                 ))}
                             </SelectContent>
                         </Select>
                     </div>

                    {/* Notes */}
                    <div className="grid grid-cols-3 items-start gap-4">
                        <Label htmlFor="notes" className="text-right pt-1">Notes</Label>
                        <Textarea id="notes" value={notes} onChange={e => setNotes(e.target.value)} placeholder="Add any notes about this session..." className="col-span-2 min-h-[60px]" />
                    </div>
                </div>
                <DialogFooter className="pt-4 border-t">
                    <Button type="button" variant="outline" onClick={handleClose}>Cancel</Button>
                    <Button type="button" onClick={handleSave} disabled={isSaving || !duration || duration <= 0}>
                        {isSaving ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Save className="mr-2 h-4 w-4" />} Log Session
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
}; 