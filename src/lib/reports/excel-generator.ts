import { format } from 'date-fns';
import { ReportContent, LogEntry } from './types';
import * as XLSX from 'xlsx';

/**
 * Generate an Excel report from the provided content
 */
export const generateExcel = async (content: ReportContent): Promise<{ url: string }> => {
  const { template, userData, dateRange, data, includeNotes } = content;
  const workbook = XLSX.utils.book_new();

  // Create overview sheet
  const overviewData: (string | number)[][] = [
    [template.name],
    [`Report Period: ${dateRange.startDate} to ${dateRange.endDate}`],
    []
  ];

  // Add user information if included
  if (userData) {
    overviewData.push(
      ['Patient Information'],
      ['Name', userData.full_name],
      ['Date of Birth', userData.dob ? format(new Date(userData.dob), 'MM/dd/yyyy') : 'N/A'],
      ['Quit Date', userData.quit_date ? format(new Date(userData.quit_date), 'MM/dd/yyyy') : 'N/A'],
      []
    );
  }

  // Add overview sheet
  const overviewSheet = XLSX.utils.aoa_to_sheet(overviewData);
  XLSX.utils.book_append_sheet(workbook, overviewSheet, 'Overview');

  // Add section sheets
  template.sections.filter(s => s.selected).forEach(section => {
    const sectionData = data[section.dataType] || [];
    const sheetData: (string | number)[][] = [];

    // Add section header
    sheetData.push(
      [section.title],
      [section.description],
      []
    );

    // Add data table
    if (sectionData.length > 0) {
      // Add headers
      const headers = getTableHeaders(section.dataType);
      sheetData.push(headers);

      // Add data rows
      sectionData.forEach(item => {
        const row = formatDataRow(item, section.dataType);
        sheetData.push(row);
      });
    } else {
      sheetData.push(['No data available for this period']);
    }

    // Create sheet
    const sheet = XLSX.utils.aoa_to_sheet(sheetData);
    XLSX.utils.book_append_sheet(workbook, sheet, section.title.slice(0, 31)); // Excel sheet names limited to 31 chars
  });

  // Add notes sheet if included
  if (includeNotes) {
    const notesData: (string | number)[][] = [
      ['Notes & Observations'],
      [],
      ['Date', 'Type', 'Notes']
    ];

    let hasNotes = false;
    Object.entries(data).forEach(([type, items]) => {
      items.forEach((item: LogEntry) => {
        if (item.notes) {
          hasNotes = true;
          notesData.push([
            format(new Date(item.date), 'MM/dd/yyyy'),
            type,
            item.notes
          ]);
        }
      });
    });

    if (!hasNotes) {
      notesData.push(['No notes available for this period']);
    }

    const notesSheet = XLSX.utils.aoa_to_sheet(notesData);
    XLSX.utils.book_append_sheet(workbook, notesSheet, 'Notes');
  }

  // Add disclaimer sheet
  const disclaimerData: string[][] = [
    ['Disclaimer'],
    [],
    ['This report was generated by Mission Fresh.'],
    ['Data is based on self-reported information and may not be medically verified.']
  ];
  const disclaimerSheet = XLSX.utils.aoa_to_sheet(disclaimerData);
  XLSX.utils.book_append_sheet(workbook, disclaimerSheet, 'Disclaimer');

  // Generate Excel file
  const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  return {
    url: URL.createObjectURL(blob)
  };
};

function getTableHeaders(dataType: string): string[] {
  switch (dataType) {
    case 'smoking':
      return ['Date', 'Cigarettes', 'Craving Level', 'Triggers'];
    case 'mood':
      return ['Date', 'Mood Score', 'Notes'];
    default:
      return ['Date', 'Value', 'Notes'];
  }
}

function formatDataRow(item: LogEntry, dataType: string): (string | number)[] {
  const date = format(new Date(item.date), 'MM/dd/yyyy');

  switch (dataType) {
    case 'smoking':
      const smokingItem = item as any;
      return [
        date,
        smokingItem.cigarettes || 0,
        smokingItem?.cravings || 0,
        smokingItem.triggers?.join(', ') || ''
      ];
    case 'mood':
      const moodItem = item as any;
      return [
        date,
        moodItem.score || 0,
        moodItem.notes || ''
      ];
    default:
      return [
        date,
        item.value || 0,
        item.notes || ''
      ];
  }
} 